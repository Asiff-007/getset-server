<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lucky Slingshot</title>
</head>
<style type="text/css">
*
{
    margin: 0;
    padding: 0;
}

html,
body
{
    height: 100vh;
    font-family: 'Poppins';
}

.webgl
{
    position: fixed;
    top: 0;
    left: 0;
    outline: none;
    z-index: -1;
}

.main
{
    position: absolute;
    margin: auto;
    top: 10%;
    width: 100%;
}

h2, h1
{
    font-size: 5em;
}

h3
{
    font-size: 2.5em;
}

.game_text
{
    color: white;
    text-align: center;
}

</style>
<body>
    <div class="main">
        <div id="game_prize_desc" style="display: none;"><h2 class="game_text win_title">You have won</h2></div>
        <div id="game_prize_title" style="display: none;"><h1 id="game_prize_title_head" class="game_text win_desc"></h1></div>
        <h3 id="game_prize_reveal_prompt" style="display: none;" class="game_text win_desc">Tap to reveal gift</h3></div>
    </div>

    <canvas class="webgl"></canvas>
    <script src="../lib/three.js"></script>
    <script type="module">
      //import * as THREE from 'three'
      //import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
      //import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
      import { GLTFLoader } from"../lib/GLTFLoader.js";

      var prize = "<%= price %>";
      var ball_ref;
      var gltf_global;
      var is_ready = false;
      var is_pressed = false;
      var gift_clone;
      var gift_boxes = Array();
      var final_gift;
      var is_ready_for_reveal = false;

      const glb_loader = new GLTFLoader();
      const canvas = document.querySelector('canvas.webgl');
      const scene = new THREE.Scene();
      const geometry = new THREE.TorusGeometry(.1, .05, 16, 100);
      const material = new THREE.MeshStandardMaterial();
      material.color = new THREE.Color(0xff0000);

      const tl = new THREE.TextureLoader();
      var mouse = new THREE.Vector2();

      var mouse_drag_diff = 0;
      var mouse_drag_threshold = 45;

      var is_ball_dragged = false;

      var initial_pos = new THREE.Vector2();
      var current_pos = new THREE.Vector2();

      var ball_speed = -50;

      // Lights
      const pointLight = new THREE.PointLight(0xffffff, 0.01, 100);
      pointLight.position.x = 1;
      pointLight.position.y = 1;
      pointLight.position.z = 4;

      const ambientLight = new THREE.AmbientLight(0xffffff);
      scene.add(pointLight, ambientLight);


      /**
       * Sizes
       */
      const sizes = {
          width: window.innerWidth,
          height: window.innerHeight
      };


      /**
       * Camera
       */
      // Base camera
      const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 1000);
      camera.position.x = 0;
      camera.position.y = 0;
      camera.position.z = 2;
      scene.add(camera);

      const spaceTexture = tl.load('../assets/lucky_slingshot/night_sky.jpg');
      scene.background = spaceTexture;


      // const lightHelper = new THREE.PointLightHelper(pointLight);
      // scene.add(lightHelper);

      function addStar() {
          const sphereGeometry = new THREE.SphereGeometry(0.05);
          const material = new THREE.MeshStandardMaterial({color: 0xffffff});
          const star = new THREE.Mesh(sphereGeometry, material);

          const [x, y, z] = Array(3).fill().map(() => THREE.MathUtils.randFloatSpread(200));

          star.position.set(x, y, z);
          scene.add(star);
      }

      function populateGift() {
          var giftMesh;
          glb_loader.load( '../assets/lucky_slingshot/giftbox.glb', function ( gltf ) {
              giftMesh = gltf.scene;
              gltf_global = gltf;

              var z = -30; var i = 0;
              Array(100).fill().forEach(() => {
                  gift_clone = gltf.scene.clone();
                  const [x, y] = Array(3).fill().map(() => THREE.MathUtils.randFloatSpread(60));
                  z -= i*.5;
                  i++;
          
                  gift_clone.position.set(x, y, z);
                  scene.add(gift_clone);
                  gift_boxes.push(gift_clone);
              });
          
          }, undefined, function (error) {
              console.error(error);
              is_ready = false;
          } );
      }

      function addSlingshot() {
          glb_loader.load( '../assets/lucky_slingshot/slingshot.glb', function ( gltf ) {
              var slingshot_clone = gltf.scene.clone();
              
              slingshot_clone.position.set(0, -3, -5);
              scene.add(slingshot_clone);
          }, undefined, function (error) {
              console.error( error );
              is_ready = false;
          } );
      }

      function addBall() {
          const ball = new THREE.Mesh(
              new THREE.SphereGeometry(0.3),
              new THREE.MeshStandardMaterial({color: 0xff0000})
          );
          ball.position.set(0, -1, -5);
          
          ball_ref = ball;
          scene.add(ball);
      }

      function looseBall() {
          is_ready = false;
          ball_ref.alive = true;
          setTimeout(function () {
              const position = ball_ref.position;
              ball_ref.alive = false;
              scene.remove(ball_ref);
              
              final_gift = gift_clone.clone();
              final_gift.position.set(position.x, position.y, position.z - 2);
              scene.add(final_gift);
              setTimeout(function () {
                is_ready_for_reveal = true;
                document.getElementById('game_prize_reveal_prompt').style.display = 'block';
              }, 200);
          }, 5000);
      }

      Array(10000).fill().forEach(addStar);
      populateGift();
      addSlingshot();
      addBall();
      is_ready = true;

      function getCanvasRelativePosition(event, isTouch = false) {
          const rect = canvas.getBoundingClientRect();

          if (isTouch) {
              event.clientY = event.changedTouches[0].clientY;
              event.clientX = event.changedTouches[0].clientX;
          }
          return {
            x: (event.clientX - rect.left) * canvas.width  / rect.width,
            y: (event.clientY - rect.top ) * canvas.height / rect.height,
          };
      }

      window.addEventListener('resize', () =>
      {
          // Update sizes
          sizes.width = window.innerWidth
          sizes.height = window.innerHeight

          // Update camera
          camera.aspect = sizes.width / sizes.height
          camera.updateProjectionMatrix()

          // Update renderer
          renderer.setSize(sizes.width, sizes.height)
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
      });



      function handleMove(point) {
          current_pos.x = point.x;
          current_pos.y = point.y;
          
          if (current_pos.y > initial_pos.y) {
              mouse_drag_diff = initial_pos.distanceTo(current_pos);
          } else {
              mouse_drag_diff = 0;
          }
      }

      function handleDown(point) {
          is_pressed = true;
          is_ball_dragged = true;

          mouse.x = point.x;
          mouse.y = point.y;

          initial_pos.x = mouse.x;
          initial_pos.y = mouse.y;

          if (is_ready_for_reveal) {

            // play gift reveal animation here
            document.getElementById('game_prize_reveal_prompt').style.display = 'none';
            document.getElementById('game_prize_desc').style.display = 'block';
            document.getElementById('game_prize_title').style.display = 'block';
            document.getElementById('game_prize_title_head').innerHTML = prize + "!";
          }

          console.log("mouse down");
      }

      function handleUp() {
          is_pressed = false;
          is_ball_dragged = false;

          initial_pos.x = null;
          initial_pos.y = null;

          if (is_ready) {
              if (mouse_drag_diff > mouse_drag_threshold) {
                  console.log("firing initiate");
                  looseBall();
              } else {
                  // reset position
                  ball_ref.position.lerp(new THREE.Vector3(0, -1, -5), 0.9);
              }
          }
          
          // reset drag diff
          mouse_drag_diff = 0;
          
          
          console.log("mouse up");
      }

      function handleMouseMove() {
          if (is_pressed && is_ready) {
              const point = getCanvasRelativePosition(event);
              event.preventDefault();
              handleMove(point);
          }
      }

      function handleMouseDown() {
          const point = getCanvasRelativePosition(event);
          handleDown(point);
      }

      function handleMouseUp() {
          handleUp();
      }

      function handleTouchStart() {
          const point = getCanvasRelativePosition(event, true);
          handleDown(point);
      }

      function handleTouchEnd() {
          handleUp();
      }

      function handleTouchMove() {
          if (is_pressed && is_ready) {
              const point = getCanvasRelativePosition(event, true);
              event.preventDefault();
              handleMove(point);
          }
      }

      window.addEventListener('mousemove', handleMouseMove, false);
      window.addEventListener('mousedown', handleMouseDown, false);
      window.addEventListener('mouseup', handleMouseUp, false);
      window.addEventListener('touchstart', handleTouchStart, false);
      window.addEventListener('touchend', handleTouchEnd, false);
      window.addEventListener('touchmove', handleTouchMove, false);


      // Controls
      // const controls = new OrbitControls(camera, canvas);
      // controls.enableDamping = true

      /**
       * Renderer
       */
      const renderer = new THREE.WebGLRenderer({
          canvas: canvas
      });
      renderer.setSize(sizes.width, sizes.height);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      /**
       * Animate
       */

      const clock = new THREE.Clock();

      const tick = () =>
      {

          const delta = clock.getDelta();
          const elapsedTime = clock.getElapsedTime();

          // Update Orbital Controls
          //controls.update()

          if (ball_ref.alive) {
              ball_ref.translateZ( ball_speed * delta);
              ball_ref.translateY( .01 * delta);
              camera.position.lerp(new THREE.Vector3(ball_ref.position.x, ball_ref.position.y, ball_ref.position.z), 0.1);
          }
          if (final_gift) {
              final_gift.rotation.y = .2 * elapsedTime;
          }
          gift_boxes.forEach(element => {
              element.rotation.y = .2 * elapsedTime;
              element.rotation.x = .01 * elapsedTime;
          });
          if (is_ball_dragged && ball_ref.position.z < -2) {
              ball_ref.position.z = ball_ref.position.z + (.1 * mouse_drag_diff * delta);
              ball_ref.position.y = ball_ref.position.y - (.01 * mouse_drag_diff * delta);
          }

          // Render
          renderer.render(scene, camera);

          // Call tick again on the next frame
          window.requestAnimationFrame(tick);
      }

      tick();
    </script>
</body>
</html>